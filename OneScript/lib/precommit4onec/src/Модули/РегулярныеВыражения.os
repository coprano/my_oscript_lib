// Создать
//	Создает объект встроенного языка и возвращает его
// Параметры:
//   ТекстВыражения			- Строка - Текст выражения
//   ИгнорироватьРегистр	- Булево - Если включено, регистр символов не важен для поиска
//   Многострочный			- Булево - Если включено, ^ и $ соответствуют началу и концу строки
//
//  Возвращаемое значение:
//   РегулярноеВыражение - Объект
//
Функция Создать(ТекстВыражения,  ИгнорироватьРегистр = Истина, Многострочный = Истина) Экспорт

	Выражение = Новый РегулярноеВыражение(ТекстВыражения);
	Выражение.ИгнорироватьРегистр = ИгнорироватьРегистр;
	Выражение.Многострочный = Многострочный;

	Возврат Выражение;
 
КонецФункции

Функция ПолучитьДочерниеЭлементыОписанияКонфигурации(Знач СодержимоеФайла, ЭтоEDT) Экспорт
	
	Элементы = Новый Структура("Количество,ДочерниеЭлементыСтрока,Совпадения", 0, "", Неопределено);
	
	Если ЭтоEDT Тогда
		Регексп = Создать("(<\/languages>\s+)^(?!.*languages)([\w\W]*)(<\/mdclass\:Configuration>)");
	Иначе
		Регексп = Создать("(<ChildObjects>\s+?)([\w\W]+?)(\s+<\/ChildObjects>)");
	КонецЕсли;
	
	ДочерниеЭлементы = Регексп.НайтиСовпадения(СодержимоеФайла);
	Элементы.Количество = ДочерниеЭлементы.Количество();
	Элементы.Совпадения = ДочерниеЭлементы;
	
	Если НЕ Элементы.Количество = 0 Тогда // Если количество 0 вернется пустая коллекция
		
		Элементы.ДочерниеЭлементыСтрока = ДочерниеЭлементы[0].Группы[2].Значение;

		Если ЭтоEDT Тогда
			РегекспМетаданные = Создать("^\s+<[\w]+>([a-zA-Z]+)\.([а-яёa-zA-ZА-ЯЁ0-9_]+)<\/[\w]+>");
		Иначе
			РегекспМетаданные = Создать("^\s+<([\w]+)>([а-яёa-zA-ZА-ЯЁ0-9_]+)<\/[\w]+>");
		КонецЕсли;

		Элементы.Совпадения = РегекспМетаданные.НайтиСовпадения(Элементы.ДочерниеЭлементыСтрока);
		
	КонецЕсли;
	
	Возврат Элементы;

КонецФункции

#Область ПостроительШаблонов

Функция ШаблонПроизвольногоЗначения(Квантификатор = "*")
	Возврат "[\w\W]" + Квантификатор;
КонецФункции

Функция ШаблонПроизвольногоЗначенияДоНачалаРазметки(Квантификатор = "*")
	Возврат "[^<]" + Квантификатор;
КонецФункции

Функция ШаблонПроизвольногоЗначенияДоКонцаРазметки(Квантификатор = "*")
	Возврат "[^>]" + Квантификатор;
КонецФункции

Функция ШаблонАтрибутовЭлемента()
	Возврат "\s+" + ШаблонПроизвольногоЗначенияДоКонцаРазметки("+");
КонецФункции

Функция ЛенивыйПоиск(Выражение)
	Возврат Выражение + "?";
КонецФункции

Функция ЗахватитьВГруппу(Выражение, ИмяГруппы = "")

	ОбозначениеГруппы = "";
	Если ЗначениеЗаполнено(ИмяГруппы) Тогда
		ОбозначениеГруппы = СтрШаблон("?<%1>", ИмяГруппы);
	КонецЕсли;

	Возврат СтрШаблон("(%1%2)", ОбозначениеГруппы, Выражение);
	
КонецФункции

Функция СсылкаНаГруппу(ИмяГруппы)
	Возврат СтрШаблон("k<%1>", ИмяГруппы);
КонецФункции

Функция ДобавитьНачальнуюРазметкуЭлемента(ИмяЭлемента, ЭлементИмеетАтрибуты = Ложь)

	ТекстАтрибутов = "";
	Если ЭлементИмеетАтрибуты Тогда
		ТекстАтрибутов = ШаблонАтрибутовЭлемента();
	КонецЕсли;

	Возврат СтрШаблон("<%1%2>", ИмяЭлемента, ТекстАтрибутов);

КонецФункции

Функция ДобавитьКонечнуюРазметкуЭлемента(ИмяЭлемента)
	Возврат СтрШаблон("<\/%1>", ИмяЭлемента);
КонецФункции

Функция ДобавитьОтступыЭлемента(Выражение)
	Возврат "\s*" + Выражение + "[ \t]*\n*";
КонецФункции

Функция ШаблонЗначенияЭлемента(ЭлементИмеетВложения = Ложь, ЛенивыйПоиск = Ложь, ЗахватитьЗначение = Ложь)

	Результат = ?(ЭлементИмеетВложения, "[\w\W]*", "[^<]*");

	Если ЛенивыйПоиск Тогда
		ЛенивыйПоиск(Результат);
	КонецЕсли;

	Если ЗахватитьЗначение Тогда
		ЗахватитьВГруппу(Результат, "value");
	КонецЕсли;

	Возврат Результат;

КонецФункции

Функция ШаблонЭлемента(ИмяЭлемента, ЗначениеЭлемента, ЭлементИмеетАтрибуты = Ложь, ВключитьОтступы = Истина, ЗахватитьИмя = Ложь)

	ОткрывающийТег = ИмяЭлемента;
	ЗакрывающийТег = ИмяЭлемента;
	
	Если ЗахватитьИмя Тогда
		ИмяГруппыИмяЭлемента = "name";
		ОткрывающийТег = ЗахватитьВГруппу(ОткрывающийТег, ИмяГруппыИмяЭлемента);
		ЗакрывающийТег = СсылкаНаГруппу(ИмяГруппыИмяЭлемента);
	КонецЕсли;

	ОткрывающийТег = ДобавитьНачальнуюРазметкуЭлемента(ОткрывающийТег, ЭлементИмеетАтрибуты);
	ЗакрывающийТег = ДобавитьКонечнуюРазметкуЭлемента(ЗакрывающийТег);
	
	Результат = ОткрывающийТег + ЗначениеЭлемента + ЗакрывающийТег;

	Если ВключитьОтступы Тогда
		Результат = ДобавитьОтступыЭлемента(Результат);
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

#КонецОбласти