#Использовать reflector

Перем Рефлектор;

// Получает тип объекта, вокруг которого построен декоратор (рекурсивно).
//
// Параметры:
//   Декоратор - Произвольный - Объект, у которого нужно найти исходный тип объекта
//
//  Возвращаемое значение:
//   Тип - Исходный тип объекта
//
Функция ИсходныйТип(Декоратор) Экспорт
	Рефлектор = Новый Рефлектор();
	
	Попытка
		ИсходныйОбъект = Рефлектор.ПолучитьСвойство(Декоратор, Константы_Декоратор.Поле_ИнстансОбъекта);
		Возврат ИсходныйТип(ИсходныйОбъект);
	Исключение
		Возврат ТипЗнч(Декоратор);
	КонецПопытки;
	
КонецФункции

// Синхронизировать значения экспортных полей двух объектов.
//
// Параметры:
//   ИсходныйОбъект - Произвольный - Источник значений свойств
//   Потребитель - Произвольный - Получатель значений свойств
//
Процедура СинхронизироватьПоля(ИсходныйОбъект, Потребитель) Экспорт

	Если Не ЗначениеЗаполнено(ИсходныйОбъект)
		Или Не ЗначениеЗаполнено(Потребитель) Тогда
		Возврат;
	КонецЕсли;

	ИменаПолейДекоратора = Новый Массив;
	ИменаПолейДекоратора.Добавить("Декоратор_ИсходныйОбъект");
	ИменаПолейДекоратора.Добавить("Декоратор_Лог");

	СвойстваИсходногоОбъекта = Рефлектор.ПолучитьТаблицуСвойств(ИсходныйОбъект, Истина);
	СвойстваПотребителя      = Рефлектор.ПолучитьТаблицуСвойств(Потребитель, Истина);
	
	Для Каждого Свойство Из СвойстваИсходногоОбъекта Цикл
		
		ИмяСвойства = Свойство.Имя;
		
		Если ИменаПолейДекоратора.Найти(ИмяСвойства) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если СвойстваПотребителя.Найти(ИмяСвойства, "Имя") = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		ЗначениеСвойства = Рефлектор.ПолучитьСвойство(ИсходныйОбъект, ИмяСвойства);
		Рефлектор.УстановитьСвойство(Потребитель, ИмяСвойства, ЗначениеСвойства);
	
	КонецЦикла;

КонецПроцедуры

// #Область Инициализация

Рефлектор = Новый Рефлектор();

// #КонецОбласти
