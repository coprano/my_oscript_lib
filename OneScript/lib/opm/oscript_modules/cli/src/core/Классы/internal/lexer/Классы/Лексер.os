
#Использовать logos

Перем СтрокаАнализа;
Перем МассивТокенов;

Перем ОшибкаЧтения;
Перем ПодробноеОписаниеОшибки;

Перем Лог;

Процедура ПриСозданииОбъекта(Знач ВходящаяСтрока)

	СтрокаАнализа = ВходящаяСтрока;

	МассивТокенов = Новый Массив;
	ОшибкаЧтения = "";

	ПодробноеОписаниеОшибки = Новый Структура;

КонецПроцедуры

// Выполняет чтение строки по токенам и возвращает текущий класс
//
//  Возвращаемое значение:
//   Лексер - ссылка на текущий класс <Лексер>
//
Функция Прочитать() Экспорт

	МассивТокенов.Очистить();

	ПрочитатьТокены();

	Возврат ЭтотОБъект;

КонецФункции

// Возвращает массив токенов
//
//  Возвращаемое значение:
//   массив - массив токенов после чтения строки
//
Функция ПолучитьТокены() Экспорт

	Если ЕстьОшибка() Тогда
		Возврат Новый Массив;
	КонецЕсли;

	Возврат МассивТокенов;

КонецФункции

// Выводит ошибку чтения строки
//
Процедура ВывестиИнформациюОбОшибке() Экспорт

	Сообщить("Ошибка разбора строки: " + ОшибкаЧтения);

КонецПроцедуры

// Возвращает описание ошибки чтения строки
//
//  Возвращаемое значение:
//   строка - подробное описание ошибки чтения строки
//
Функция ПолучитьИнформациюОбОшибке() Экспорт

	Возврат ОшибкаЧтения;

КонецФункции

// Проверяет наличие ошибки чтения строки
//
//  Возвращаемое значение:
//   булево - Истина, если есть ошибка чтения
//
Функция ЕстьОшибка() Экспорт
	Возврат Не ПустаяСтрока(ОшибкаЧтения);
КонецФункции

Процедура ПрочитатьТокены()

	МассивТокенов.Очистить();
	Чтение = Новый ЧтениеСтроки(СтрокаАнализа);

	Пока Чтение.Читать() Цикл

		ТекущийСимвол = Чтение.ТекущийСимвол();
		ТекущийИндекс = Чтение.ТекущийИндекс();
		Лог.Отладка("Текущий символ: %1", ТекущийСимвол);
		Лог.Отладка("Текущий индекс: %1", ТекущийИндекс);

		Если Чтение.ЭтоСимвол(" ")
			ИЛИ Чтение.ЭтоСимвол(Символы.ПС) Тогда
			Продолжить;
		ИначеЕсли Чтение.ЭтоСимвол("[") Тогда
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTOpenSq, ТекущийСимвол, ТекущийИндекс));
		ИначеЕсли Чтение.ЭтоСимвол("]") Тогда
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTCloseSq, ТекущийСимвол, ТекущийИндекс));
		ИначеЕсли Чтение.ЭтоСимвол("(") Тогда
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTOpenPar, ТекущийСимвол, ТекущийИндекс));
		ИначеЕсли Чтение.ЭтоСимвол(")") Тогда
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTClosePar, ТекущийСимвол, ТекущийИндекс));
		ИначеЕсли Чтение.ЭтоСимвол("|") Тогда
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTChoice, ТекущийСимвол, ТекущийИндекс));
		ИначеЕсли Чтение.ЭтоСимвол(".") Тогда

			ДополнительнаяДлинаТроеточия = 2;
			Троеточие = Чтение.ВСтроку(ТекущийИндекс, ТекущийИндекс + ДополнительнаяДлинаТроеточия);

			Если Не Троеточие = "..." Тогда
				ОшибкаЧтения = "Ошибка в строке Спек, неправильно использованы символы <...>, должно быть 3";
				Прервать;
			КонецЕсли;

			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTRep, Троеточие, ТекущийИндекс));
			Чтение.ЧитатьНа(ДополнительнаяДлинаТроеточия);

		ИначеЕсли Чтение.ЭтоСимвол("-") Тогда

			СтартоваяПозиция = ТекущийИндекс;

			Если Не Чтение.Читать() Тогда
				ОшибкаЧтения = "Ошибка в строке Спек, не указано имя опции";
				Прервать;
			КонецЕсли;

			Если Чтение.ЭтоБуква() Тогда

				Чтение.ЧитатьДо("ПродолжитьЧтение = ЭтоБуква();");

				ТипТокена = ТипыТокенов().TTShortOpt;
				НазваниеТокена = Чтение.ВСтроку(СтартоваяПозиция, Чтение.ТекущийИндекс());

				ДлинаИмениТокена = 2;

				Если СтрДлина(НазваниеТокена) > ДлинаИмениТокена Тогда
					ТипТокена = ТипыТокенов().TTOptSeq;
					НазваниеТокена = Сред(НазваниеТокена, 1);
				КонецЕсли;

				МассивТокенов.Добавить(НовыйТокен(ТипТокена, НазваниеТокена, СтартоваяПозиция));

				Если НЕ Чтение.КонецСтроки()
					И Чтение.ВЧтениеСтрокиС(Чтение.ТекущийИндекс() + 1).ЭтоСимвол("-") Тогда
					ОшибкаЧтения = "Не правильный синтаксис. Короткой опции";
					Прервать;
				КонецЕсли;

			ИначеЕсли Чтение.ЭтоСимвол("-") Тогда

				Если Чтение.КонецСтроки()
					ИЛИ Чтение.СледующийСимволЭто(" ") Тогда
					МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTDoubleDash, "--", СтартоваяПозиция));
					Продолжить;
				КонецЕсли;

				Чтение.ЧитатьДо("ПродолжитьЧтение = ЭтоБуква() ИЛИ ЭтоЧисло() ИЛИ ЭтоСимвол(""_"") ИЛИ ЭтоСимвол(""-"");");

				НазваниеТокена = Чтение.ВСтроку(СтартоваяПозиция, Чтение.ТекущийИндекс());

				ДлинаКороткойОпции = 2;

				Если СтрДлина(НазваниеТокена) = ДлинаКороткойОпции Тогда
					ОшибкаЧтения = "Не правильный синтаксис. Короткой опции";
					Прервать;
				КонецЕсли;

				МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTLongOpt, НазваниеТокена, СтартоваяПозиция));

			КонецЕсли;

		ИначеЕсли Чтение.ЭтоСимвол("=") Тогда

			СтартоваяПозиция = ТекущийИндекс;

			Если Не Чтение.СледующийСимволЭто("<") Тогда
				ОшибкаЧтения = "Отсутствует начало описания опции '=<'";
				Прервать;
			КонецЕсли;

			Закрыто = Чтение.ЧитатьДоСимвола(">");

			Если Не Закрыто Тогда
				ОшибкаЧтения = "Не закрытое описание опции";
				Прервать;
			КонецЕсли;

			МинимальнаяДлинаОписанияОпции = 2;

			Если Чтение.ТекущийИндекс() - СтартоваяПозиция = МинимальнаяДлинаОписанияОпции Тогда
				ОшибкаЧтения = "Отсутствует описание опции";
				Прервать;
			КонецЕсли;

			Чтение.Читать();

			НазваниеТокена = Чтение.ВСтроку(СтартоваяПозиция, Чтение.ТекущийИндекс());
			МассивТокенов.Добавить(НовыйТокен(ТипыТокенов().TTOptValue, НазваниеТокена, СтартоваяПозиция));
		Иначе

			Лог.Отладка("Это аргумент: %1", Чтение.ЭтоБольшаяБуква());
			Если Чтение.ЭтоБольшаяБуква() Тогда

				СтартоваяПозиция = ТекущийИндекс;
				Чтение.ЧитатьДо("ПродолжитьЧтение = ЭтоБольшаяБуква() ИЛИ ЭтоЧисло() ИЛИ ЭтоСимвол(""_"");");

				НазваниеТокена = Чтение.ВСтроку(СтартоваяПозиция, Чтение.ТекущийИндекс());
				ТипТокена = ТипыТокенов().TTArg;

				Если НазваниеТокена = "OPTIONS"
					ИЛИ НазваниеТокена = "ОПЦИИ" Тогда
					ТипТокена = ТипыТокенов().TTOptions;
				КонецЕсли;

				МассивТокенов.Добавить(НовыйТокен(ТипТокена, НазваниеТокена, СтартоваяПозиция));
			Иначе
				ОшибкаЧтения = СтрШаблон("Неизвестная ошибка! Индекс в строке: %1, символ: %2 ",
										Чтение.ТекущийИндекс(),
										Чтение.ТекущийСимвол());
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Возвращает возможные типы токенов
//
//  Возвращаемое значение:
//   Структура - структура данных вида:
//    * Ключ - Имя токена
//    * Значение - представление токена
//
Функция ТипыТокенов()
	Возврат Токены.ТипыТокенов();
КонецФункции

Функция НовыйТокен(ТипТокена, Значение, Позиция)
	Возврат Токены.НовыйТокен(ТипТокена, Значение, Позиция);
КонецФункции

Лог = Логирование.ПолучитьЛог("oscript.lib.cli_lexer");